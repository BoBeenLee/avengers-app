/* tslint:disable */
/* eslint-disable */
/**
 * Shecret API
 * Shecret API 명세
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 자주 묻는 질문의 답변
 * @export
 * @interface Answer
 */
export interface Answer {
    /**
     * 
     * @type {string}
     * @memberof Answer
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface Article
 */
export interface Article {
    /**
     * 
     * @type {number}
     * @memberof Article
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    content?: string;
    /**
     * 
     * @type {User}
     * @memberof Article
     */
    user?: User;
    /**
     * 
     * @type {Array<ArticleFeedBack>}
     * @memberof Article
     */
    articleFeedBacks?: Array<ArticleFeedBack>;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Article
     */
    modifiedDate?: string;
}
/**
 * 
 * @export
 * @interface ArticleFeedBack
 */
export interface ArticleFeedBack {
    /**
     * 
     * @type {number}
     * @memberof ArticleFeedBack
     */
    id?: number;
    /**
     * 
     * @type {Article}
     * @memberof ArticleFeedBack
     */
    article?: Article;
    /**
     * 
     * @type {User}
     * @memberof ArticleFeedBack
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedBack
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedBack
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedBack
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedBack
     */
    modifiedAt?: string;
}
/**
 * 게시글 피드백 시 사용되는 객체
 * @export
 * @interface ArticleFeedbackRequest
 */
export interface ArticleFeedbackRequest {
    /**
     * 사용자가 입력한 피드백의 제목
     * @type {string}
     * @memberof ArticleFeedbackRequest
     */
    title: string;
    /**
     * 사용자가 입력한 피드백의 내용
     * @type {string}
     * @memberof ArticleFeedbackRequest
     */
    content: string;
}
/**
 * 
 * @export
 * @interface ArticleFeedbackResponse
 */
export interface ArticleFeedbackResponse {
    /**
     * 
     * @type {Article}
     * @memberof ArticleFeedbackResponse
     */
    article?: Article;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedbackResponse
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleFeedbackResponse
     */
    content?: string;
}
/**
 * 게시글 작성 시 사용되는 요청객체.
 * @export
 * @interface ArticleWriteRequest
 */
export interface ArticleWriteRequest {
    /**
     * 사용자가 입력한 게시글의 제목
     * @type {string}
     * @memberof ArticleWriteRequest
     */
    title: string;
    /**
     * 사용자가 입력한 게시글의 내용
     * @type {string}
     * @memberof ArticleWriteRequest
     */
    content: string;
}
/**
 * 회원가입을 위하여 사용되는 토큰. 10분간 유효함.
 * @export
 * @interface AuthenticationToken
 */
export interface AuthenticationToken {
    /**
     * 회원가입 토큰
     * @type {string}
     * @memberof AuthenticationToken
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface Faq
 */
export interface Faq {
    /**
     * 
     * @type {Question}
     * @memberof Faq
     */
    question?: Question;
    /**
     * 
     * @type {Answer}
     * @memberof Faq
     */
    answer?: Answer;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    authority?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    appId?: string;
}
/**
 * 로그인 객체
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 로그인 성공 시 내려가는 token 정보. 이후 헤더에 \'token\'값을 포함시켜 전송해야한다. 
     * @type {string}
     * @memberof LoginResponse
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface Nickname
 */
export interface Nickname {
    /**
     * 
     * @type {string}
     * @memberof Nickname
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Nickname
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface NicknameDto
 */
export interface NicknameDto {
    /**
     * 
     * @type {NicknamePrefix}
     * @memberof NicknameDto
     */
    nicknamePrefix?: NicknamePrefix;
    /**
     * 
     * @type {Nickname}
     * @memberof NicknameDto
     */
    nickname?: Nickname;
}
/**
 * 
 * @export
 * @interface NicknamePrefix
 */
export interface NicknamePrefix {
    /**
     * 
     * @type {string}
     * @memberof NicknamePrefix
     */
    prefix?: string;
    /**
     * 
     * @type {number}
     * @memberof NicknamePrefix
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface NicknameUpdateRequest
 */
export interface NicknameUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof NicknameUpdateRequest
     */
    prefixId?: number;
    /**
     * 
     * @type {number}
     * @memberof NicknameUpdateRequest
     */
    nicknameId?: number;
}
/**
 * 
 * @export
 * @interface Notice
 */
export interface Notice {
    /**
     * 
     * @type {string}
     * @memberof Notice
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Notice
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof Notice
     */
    writeTime?: string;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 자주 묻는 질문
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * 질문 제목
     * @type {string}
     * @memberof Question
     */
    title?: string;
    /**
     * 질문 본문
     * @type {string}
     * @memberof Question
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    deviceId: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    appId: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    appId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    verify?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nickname?: string;
    /**
     * 
     * @type {Array<Article>}
     * @memberof User
     */
    articles?: Array<Article>;
    /**
     * 
     * @type {Array<ArticleFeedBack>}
     * @memberof User
     */
    articleFeedBacks?: Array<ArticleFeedBack>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    modifiedAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    enabled?: boolean;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof User
     */
    authorities?: Array<GrantedAuthority>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    accountNonExpired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    accountNonLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    credentialsNonExpired?: boolean;
}

/**
 * Class01APIV1Api - axios parameter creator
 * @export
 */
export const Class01APIV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 모든 필드는 필수값임.
         * @summary 로그인 API
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/v1/users/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * /v1/authentications/{deviceId} API를 통하여 얻은 token으로 회원가입 시도해야함.
         * @summary 회원가입 API
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signupRequest: SignupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('signup', 'signupRequest', signupRequest)
            const localVarPath = `/v1/users/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class01APIV1Api - functional programming interface
 * @export
 */
export const Class01APIV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class01APIV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 모든 필드는 필수값임.
         * @summary 로그인 API
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * /v1/authentications/{deviceId} API를 통하여 얻은 token으로 회원가입 시도해야함.
         * @summary 회원가입 API
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signupRequest: SignupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class01APIV1Api - factory interface
 * @export
 */
export const Class01APIV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class01APIV1ApiFp(configuration)
    return {
        /**
         * 모든 필드는 필수값임.
         * @summary 로그인 API
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * /v1/authentications/{deviceId} API를 통하여 얻은 token으로 회원가입 시도해야함.
         * @summary 회원가입 API
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signupRequest: SignupRequest, options?: any): AxiosPromise<number> {
            return localVarFp.signup(signupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class01APIV1Api - object-oriented interface
 * @export
 * @class Class01APIV1Api
 * @extends {BaseAPI}
 */
export class Class01APIV1Api extends BaseAPI {
    /**
     * 모든 필드는 필수값임.
     * @summary 로그인 API
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class01APIV1Api
     */
    public login(loginRequest: LoginRequest, options?: any) {
        return Class01APIV1ApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * /v1/authentications/{deviceId} API를 통하여 얻은 token으로 회원가입 시도해야함.
     * @summary 회원가입 API
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class01APIV1Api
     */
    public signup(signupRequest: SignupRequest, options?: any) {
        return Class01APIV1ApiFp(this.configuration).signup(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class02APIApi - axios parameter creator
 * @export
 */
export const Class02APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 마지막 24시간동안 인증을 시도한 횟수.
         * @summary 인증 횟수 조회
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTodayAuthorizeCount: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('findTodayAuthorizeCount', 'deviceId', deviceId)
            const localVarPath = `/v1/authentications/{deviceId}/today-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원가입시 넘겨줘야 하는 토큰을 발급받는 API
         * @summary 회원가입 인증 토큰 발급
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryAuthentication: async (deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('tryAuthentication', 'deviceId', deviceId)
            const localVarPath = `/v1/authentications/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class02APIApi - functional programming interface
 * @export
 */
export const Class02APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class02APIApiAxiosParamCreator(configuration)
    return {
        /**
         * 마지막 24시간동안 인증을 시도한 횟수.
         * @summary 인증 횟수 조회
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTodayAuthorizeCount(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTodayAuthorizeCount(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 회원가입시 넘겨줘야 하는 토큰을 발급받는 API
         * @summary 회원가입 인증 토큰 발급
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryAuthentication(deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tryAuthentication(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class02APIApi - factory interface
 * @export
 */
export const Class02APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class02APIApiFp(configuration)
    return {
        /**
         * 마지막 24시간동안 인증을 시도한 횟수.
         * @summary 인증 횟수 조회
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTodayAuthorizeCount(deviceId: string, options?: any): AxiosPromise<number> {
            return localVarFp.findTodayAuthorizeCount(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원가입시 넘겨줘야 하는 토큰을 발급받는 API
         * @summary 회원가입 인증 토큰 발급
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryAuthentication(deviceId: string, options?: any): AxiosPromise<AuthenticationToken> {
            return localVarFp.tryAuthentication(deviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class02APIApi - object-oriented interface
 * @export
 * @class Class02APIApi
 * @extends {BaseAPI}
 */
export class Class02APIApi extends BaseAPI {
    /**
     * 마지막 24시간동안 인증을 시도한 횟수.
     * @summary 인증 횟수 조회
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class02APIApi
     */
    public findTodayAuthorizeCount(deviceId: string, options?: any) {
        return Class02APIApiFp(this.configuration).findTodayAuthorizeCount(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원가입시 넘겨줘야 하는 토큰을 발급받는 API
     * @summary 회원가입 인증 토큰 발급
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class02APIApi
     */
    public tryAuthentication(deviceId: string, options?: any) {
        return Class02APIApiFp(this.configuration).tryAuthentication(deviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class03Api - axios parameter creator
 * @export
 */
export const Class03ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFaqList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/faqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNoticeList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class03Api - functional programming interface
 * @export
 */
export const Class03ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class03ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFaqList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Faq>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFaqList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNoticeList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNoticeList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class03Api - factory interface
 * @export
 */
export const Class03ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class03ApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFaqList(options?: any): AxiosPromise<Array<Faq>> {
            return localVarFp.findFaqList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNoticeList(options?: any): AxiosPromise<Array<Notice>> {
            return localVarFp.findNoticeList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class03Api - object-oriented interface
 * @export
 * @class Class03Api
 * @extends {BaseAPI}
 */
export class Class03Api extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class03Api
     */
    public findFaqList(options?: any) {
        return Class03ApiFp(this.configuration).findFaqList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class03Api
     */
    public findNoticeList(options?: any) {
        return Class03ApiFp(this.configuration).findNoticeList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class04APIV1Api - axios parameter creator
 * @export
 */
export const Class04APIV1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 게시글 작성 API
         * @summary 게시글 작성 API
         * @param {ArticleWriteRequest} articleWriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articleWrite: async (articleWriteRequest: ArticleWriteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleWriteRequest' is not null or undefined
            assertParamExists('articleWrite', 'articleWriteRequest', articleWriteRequest)
            const localVarPath = `/v1/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 조회한 게시글 리스트 API. page는 0부터 시작하며, Page, size를 지정하여 호출
         * @summary 내가 작성한 게시글 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArticleList: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findArticleList', 'pageable', pageable)
            const localVarPath = `/v1/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 디버깅용
         * @summary 내가 작성한 피드백 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeedbackList: async (pageable: Pageable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findFeedbackList', 'pageable', pageable)
            const localVarPath = `/v1/articles/{articleId}/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 피드백 작성 API
         * @summary 피드백 작성 API
         * @param {number} articleId 
         * @param {ArticleFeedbackRequest} articleFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeFeedback: async (articleId: number, articleFeedbackRequest: ArticleFeedbackRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'articleId' is not null or undefined
            assertParamExists('writeFeedback', 'articleId', articleId)
            // verify required parameter 'articleFeedbackRequest' is not null or undefined
            assertParamExists('writeFeedback', 'articleFeedbackRequest', articleFeedbackRequest)
            const localVarPath = `/v1/articles/{articleId}/feedback`
                .replace(`{${"articleId"}}`, encodeURIComponent(String(articleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(articleFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class04APIV1Api - functional programming interface
 * @export
 */
export const Class04APIV1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class04APIV1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 게시글 작성 API
         * @summary 게시글 작성 API
         * @param {ArticleWriteRequest} articleWriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async articleWrite(articleWriteRequest: ArticleWriteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.articleWrite(articleWriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 내가 조회한 게시글 리스트 API. page는 0부터 시작하며, Page, size를 지정하여 호출
         * @summary 내가 작성한 게시글 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findArticleList(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Article>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findArticleList(pageable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 디버깅용
         * @summary 내가 작성한 피드백 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFeedbackList(pageable: Pageable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleFeedbackResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFeedbackList(pageable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 피드백 작성 API
         * @summary 피드백 작성 API
         * @param {number} articleId 
         * @param {ArticleFeedbackRequest} articleFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeFeedback(articleId: number, articleFeedbackRequest: ArticleFeedbackRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeFeedback(articleId, articleFeedbackRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class04APIV1Api - factory interface
 * @export
 */
export const Class04APIV1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class04APIV1ApiFp(configuration)
    return {
        /**
         * 게시글 작성 API
         * @summary 게시글 작성 API
         * @param {ArticleWriteRequest} articleWriteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        articleWrite(articleWriteRequest: ArticleWriteRequest, options?: any): AxiosPromise<number> {
            return localVarFp.articleWrite(articleWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 조회한 게시글 리스트 API. page는 0부터 시작하며, Page, size를 지정하여 호출
         * @summary 내가 작성한 게시글 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArticleList(pageable: Pageable, options?: any): AxiosPromise<Array<Article>> {
            return localVarFp.findArticleList(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 디버깅용
         * @summary 내가 작성한 피드백 리스트 조회 API
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeedbackList(pageable: Pageable, options?: any): AxiosPromise<Array<ArticleFeedbackResponse>> {
            return localVarFp.findFeedbackList(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 피드백 작성 API
         * @summary 피드백 작성 API
         * @param {number} articleId 
         * @param {ArticleFeedbackRequest} articleFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeFeedback(articleId: number, articleFeedbackRequest: ArticleFeedbackRequest, options?: any): AxiosPromise<number> {
            return localVarFp.writeFeedback(articleId, articleFeedbackRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class04APIV1Api - object-oriented interface
 * @export
 * @class Class04APIV1Api
 * @extends {BaseAPI}
 */
export class Class04APIV1Api extends BaseAPI {
    /**
     * 게시글 작성 API
     * @summary 게시글 작성 API
     * @param {ArticleWriteRequest} articleWriteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class04APIV1Api
     */
    public articleWrite(articleWriteRequest: ArticleWriteRequest, options?: any) {
        return Class04APIV1ApiFp(this.configuration).articleWrite(articleWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 조회한 게시글 리스트 API. page는 0부터 시작하며, Page, size를 지정하여 호출
     * @summary 내가 작성한 게시글 리스트 조회 API
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class04APIV1Api
     */
    public findArticleList(pageable: Pageable, options?: any) {
        return Class04APIV1ApiFp(this.configuration).findArticleList(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 디버깅용
     * @summary 내가 작성한 피드백 리스트 조회 API
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class04APIV1Api
     */
    public findFeedbackList(pageable: Pageable, options?: any) {
        return Class04APIV1ApiFp(this.configuration).findFeedbackList(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 피드백 작성 API
     * @summary 피드백 작성 API
     * @param {number} articleId 
     * @param {ArticleFeedbackRequest} articleFeedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class04APIV1Api
     */
    public writeFeedback(articleId: number, articleFeedbackRequest: ArticleFeedbackRequest, options?: any) {
        return Class04APIV1ApiFp(this.configuration).writeFeedback(articleId, articleFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NicknameControllerApi - axios parameter creator
 * @export
 */
export const NicknameControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 각각 랜덤의 prefix, nickname을 가져온다.
         * @summary 랜덤 닉네임 가져오기 API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRandomNickname: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/nicknames/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 닉네임을 변경한다. 추 후 유료 사용자와 무료 사용자의 격차를 둘 로직이 들어갈 예정임.
         * @summary 닉네임 변경 API
         * @param {NicknameUpdateRequest} nicknameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickname: async (nicknameUpdateRequest: NicknameUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nicknameUpdateRequest' is not null or undefined
            assertParamExists('updateNickname', 'nicknameUpdateRequest', nicknameUpdateRequest)
            const localVarPath = `/v1/nicknames`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nicknameUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NicknameControllerApi - functional programming interface
 * @export
 */
export const NicknameControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NicknameControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 각각 랜덤의 prefix, nickname을 가져온다.
         * @summary 랜덤 닉네임 가져오기 API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRandomNickname(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NicknameDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRandomNickname(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 닉네임을 변경한다. 추 후 유료 사용자와 무료 사용자의 격차를 둘 로직이 들어갈 예정임.
         * @summary 닉네임 변경 API
         * @param {NicknameUpdateRequest} nicknameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNickname(nicknameUpdateRequest: NicknameUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNickname(nicknameUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NicknameControllerApi - factory interface
 * @export
 */
export const NicknameControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NicknameControllerApiFp(configuration)
    return {
        /**
         * 각각 랜덤의 prefix, nickname을 가져온다.
         * @summary 랜덤 닉네임 가져오기 API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRandomNickname(options?: any): AxiosPromise<NicknameDto> {
            return localVarFp.findRandomNickname(options).then((request) => request(axios, basePath));
        },
        /**
         * 닉네임을 변경한다. 추 후 유료 사용자와 무료 사용자의 격차를 둘 로직이 들어갈 예정임.
         * @summary 닉네임 변경 API
         * @param {NicknameUpdateRequest} nicknameUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickname(nicknameUpdateRequest: NicknameUpdateRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.updateNickname(nicknameUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NicknameControllerApi - object-oriented interface
 * @export
 * @class NicknameControllerApi
 * @extends {BaseAPI}
 */
export class NicknameControllerApi extends BaseAPI {
    /**
     * 각각 랜덤의 prefix, nickname을 가져온다.
     * @summary 랜덤 닉네임 가져오기 API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicknameControllerApi
     */
    public findRandomNickname(options?: any) {
        return NicknameControllerApiFp(this.configuration).findRandomNickname(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 닉네임을 변경한다. 추 후 유료 사용자와 무료 사용자의 격차를 둘 로직이 들어갈 예정임.
     * @summary 닉네임 변경 API
     * @param {NicknameUpdateRequest} nicknameUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicknameControllerApi
     */
    public updateNickname(nicknameUpdateRequest: NicknameUpdateRequest, options?: any) {
        return NicknameControllerApiFp(this.configuration).updateNickname(nicknameUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


